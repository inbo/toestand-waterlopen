library(sf)
library(terra)
library(whitebox)  # for hydrology functions
library(igraph)    # for graph-based connectivity
library(tidyverse)
library(here)
library(qgisprocess)
library(sf)
library(nngeo)
library(igraph)
library(lubridate)
library(mapview)

fd <- st_read(here("data", "ruw", "netwerk", "Flow_direction_coordinates.shp"))
nodes <- st_read(here("data", "ruw", "waterlopen", "vha_network_junctions.shp"))

# Calculate from_node and to_node based on Start and End coordinates
# Convert the Start and End coordinates into POINT geometries
start_points <- st_as_sf(data.frame(
  x = fd$StartX,
  y = fd$StartY
), coords = c("x", "y"), crs = st_crs(fd))

end_points <- st_as_sf(data.frame(
  x = fd$EndX,
  y = fd$EndY
), coords = c("x", "y"), crs = st_crs(fd))

# Find the nearest network node for start and end points
fd$from_node <- st_nearest_feature(start_points, nodes)
fd$to_node <- st_nearest_feature(end_points, nodes)

# Assign flow direction based on these nodes (optional: store as string)
fd$flow_dir <- "start_to_end"  # All flows are from Start -> End as defined in coords


# find nearest fc point for mafy point in space upstream and in time ----

# Load your data (adjust paths)
mafy_meetpunten_datum <- st_read(here("data", "ruw", "macrofyten", "mafy_meetpunten_datum.gpkg"))
fc_meetpunten_datum <- st_read(here("data", "ruw", "fys_chem", "fc_meetpunten.gpkg"))

mafy_meetpunten_meetplaats <- mafy_meetpunten_datum %>% #enkel de meetplaatsen, geen data
  select(meetplaats, geom) %>%
  unique()

fc_meetpunten_meetplaats <- fc_meetpunten_datum %>% #enkel de meetplaatsen, geen data
  select(meetplaats, geom) %>%
  unique()

# Convert dates if necessary
mafy_meetpunten_datum$monsternamedatum <- as.Date(mafy_meetpunten_datum$monsternamedatum)
fc_meetpunten_datum$monsternamedatum <- as.Date(fc_meetpunten_datum$monsternamedatum)

# Snap mafy points to river lines

qgis_run_algorithm(
  "native:snapgeometries",
  INPUT = mafy_meetpunten_datum,
  TOLERANCE = 100,
  REFERENCE_LAYER = fd,
  OUTPUT = here("data", "verwerkt", "hydrologisch", "mafy_snapped.gpkg"),
  .quiet = TRUE
)

mafy_snapped <- st_read(here("data", "verwerkt", "hydrologisch", "mafy_snapped.gpkg"))
# %>%
#   st_join(., mafy_meetpunten %>%
#             select(meetplaats, monsternamedatum),
#           by = "meetplaats")



# Snap quality points to river lines

qgis_run_algorithm(
  "native:snapgeometries",
  INPUT = fc_meetpunten_meetplaats,
  TOLERANCE = 100,
  REFERENCE_LAYER = fd,
  OUTPUT = here("data", "verwerkt", "hydrologisch", "fc_snapped.gpkg"),
  .quiet = TRUE
)
fc_snapped_meetplaats <- st_read(here("data", "verwerkt", "hydrologisch", "fc_snapped.gpkg"))

fc_no_geom <- fc_meetpunten_datum %>%
  st_drop_geometry()

fc_snapped <- fc_snapped_meetplaats %>% #enkel meetplaatsen snappen om dan terug datums toe te voegen om tijd te besparen
  left_join(., fc_no_geom, by = "meetplaats")

#plotten
mapview(mafy_snapped, color = "red", legend = FALSE) +
  # mapview(mafy_meetpunten_meetplaats, color = "green", legend = F) +
  mapview(fc_snapped_meetplaats, color = "yellow", legend = F) +
  mapview(nodes, color = "blue", legend = F) +
  mapview(st_simplify(fd))

# Assign each snapped point to nearest river segment
mafy_snapped$segment_id <- st_nearest_feature(mafy_snapped, fd)
fc_snapped$segment_id <- st_nearest_feature(fc_snapped, fd)

# Map river segments to from_node (start) and assign to snapped points
segment_to_node_from <- setNames(fd$from_node, seq_len(nrow(fd)))
mafy_snapped$node <- segment_to_node_from[mafy_snapped$segment_id]
fc_snapped$node <- segment_to_node_from[fc_snapped$segment_id]

# Build river network graph using from_node and to_node directly
edges <- data.frame(
  from = as.character(fd$from_node),
  to = as.character(fd$to_node),
  segment_id = seq_len(nrow(fd))
)

g <- graph_from_data_frame(edges, directed = TRUE)


# Initialize results
results <- list()

# For each mafy point, find closest upstream quality point within 3 months
for (i in seq_len(nrow(mafy_snapped))) {
  mpt <- mafy_snapped[i, ]
  mdate <- mpt$monsternamedatum
  mnode <- as.character(mpt$node)

  upstream_nodes <- subcomponent(g, v = mnode, mode = "in") %>% names()

  #geen within segment filtering -> maar is niet erg dat er een downstream fc punt wordt genomen, gezien het op hetzelfde segment ligt en dus waarschijnlijk dichtbij

  candidates <- fc_snapped %>%
    filter(
      as.character(node) %in% upstream_nodes,
      {
        days_before <- as.numeric(difftime(mdate, monsternamedatum, units = "days"))
        days_before >= 30 & days_before <= 90
      }
    )

  # candidates <- fc_snapped %>% #code voor 30 dagen voor en na mafy meting
  #   filter(
  #     as.character(node) %in% upstream_nodes,
  #     abs(difftime(monsternamedatum, mdate, units = "days")) <= 30
  #   )

  if (nrow(candidates) > 0) {
    # Compute distances
    dists <- st_distance(mpt, candidates)

    # Set distance threshold (x meters)
    within_threshold <- which(as.numeric(dists) <= 5000)

    if (length(within_threshold) > 0) {
      # Find the closest candidate within x meters
      closest_idx <- within_threshold[which.min(dists[within_threshold])]
      match <- candidates[closest_idx, ]
    } else {
      match <- NA
    }
  } else {
    match <- NA
  }

  results[[i]] <- list(mafy = mpt, quality = match)
}

# Convert results into a data frame
matched_mafy <- do.call(rbind, lapply(results, function(x) x$mafy))
# matched_quality <- do.call(rbind, lapply(results, function(x) x$quality))
#
# # Only keep results that have a valid 'quality' entry
# valid_quality <- lapply(results, function(x) {
#   if (!is.null(x$quality) && inherits(x$quality, "sf")) {
#     return(x$quality)
#   } else {
#     return(NULL)
#   }
# })
#
# # Remove NULLs
# valid_quality <- Filter(Negate(is.null), valid_quality)
#
# # Bind all valid quality points into one sf object
# matched_quality <- do.call(rbind, valid_quality)

#lijkt te werken
# Step 1: Get template from first valid entry
first_valid <- NULL
for (x in results) {
  if (!is.null(x$quality) && inherits(x$quality, "sf")) {
    first_valid <- x$quality[0, ]  # zero-row sf with correct structure
    break
  }
}
if (is.null(first_valid)) stop("No valid quality matches found.")

# Step 2: Create empty row constructor
make_empty_row <- function(template) {
  empty <- template[1, ]
  for (col in names(template)) {
    if (col != attr(template, "sf_column")) {
      empty[[col]] <- NA
    }
  }
  # Assign empty point geometry
  st_geometry(empty) <- st_sfc(st_point(), crs = st_crs(template))
  return(empty)
}

# Step 3: Apply logic
matched_quality <- do.call(rbind, lapply(results, function(x) {
  if (!is.null(x$quality) && inherits(x$quality, "sf")) {
    return(x$quality)
  } else {
    return(make_empty_row(first_valid))
  }
}))


# Optionally combine into one data frame
matched_df <- bind_cols(st_drop_geometry(matched_mafy), st_drop_geometry(matched_quality)) %>%
  mutate(monsternamedatum...6 = as.Date(monsternamedatum...6))
matched_sf_fd <- st_sf(matched_df, geometry = st_geometry(matched_mafy))
matched_sf_fd %>%
  drop_na(meetplaats...5) %>% nrow()

